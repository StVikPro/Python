# colors = ['red', 'green', 'blue'] # набор данных в качетсве списка
# data = open('file.txt', 'a')# создаем текстовую переменную data 
# # и связываем ее с текстовым файлом указывая путь к файлу 'file.txt' 
# # и мод дозаписи'a' любое кол-во раз, w перезапишет заново
# # data.writelines(colors) # записываем данные в качестве аргумента разделителей не будет
# data.write('\nLine2\n') # запись с переносом строк с помошью \n
# data.write('Line3\n') # запись с переносом строк с помошью \n
# data.close #закрываем файл чтобы не было утечек памяти
# exit() # позволяет не выполнять написанное ниже


#                или такой вариант вноса данных
# with open('file.txt', 'w') as data:
#     data.write('Line2\n') # запись с переносом строк с помошью \n
#     data.write('Line3\n')
# закрытие файла в данном случае произойдет автоматически



#                       ЧТЕНИЕ ФАЙЛОВ
# path = 'file.txt' # путь к папке
# data = open(path, 'r') # открываем в режиме чтения
# for line in data: # считаем строки в цикле
#     print(line) # выводим записанное
# data.close() # закроем




#         ИЗ ОДНОГО ФАЙЛА ИСПОЛЬЗУЕМ ФУНКЦИОНАЛ ДРУГОГО
# Берем из lec1.py  с 232 строки
# # import lec1
# # print(lec1.f(1)) # импортируем все что только хотим

# ИЛИ
# import lec1 as l # вводим сокрашение и прописываем при распечатке
# print(l.f(1))
# Все это помогает делить программу на несколько файлов а не
# складировать все в одной чтобы было 200-300 строк кода в одном файле


# ---------------------!!!!!!!!ФУНКЦИИ!!!!!!!!!----------------------


# #                     ВАЖНО ДЛЯ ЗАДАЧ 1 !!!

# def new_string(symbol, count):# def new_string - некоторая функция
#                               #symbol - агрумент, count - число
#         return symbol * count # возвращаем строку умноженную на число

# print(new_string('!', 5))# передав строку ! и число 5 получим #!!!!!
# print('!'))# если укажем только symbo без count будет ошибка

# Если изначально укажем допустим count=3 и введем symbol, то будет
# показано произведение их
# def new_string(symbol, count = 3):# def new_string - некоторая функция
#                               #symbol - агрумент, count - число
#         return symbol * count # возвращаем строку умноженную на число

# print(new_string(4))# при count = 3 получим перемножение с symbol


#                   ВАЖНО ДЛЯ ЗАДАЧ 2 !!!
# Функция возможности передвчи неограниченного количества аргументов

# def concatenatio(*params): # при описании функции перед аргуметом ставим *
#                            # и далее работаем с аргументом params как с набором
#         res: str = "" # прописываем для переменной тип данных чтобы были строки и могли их склеивать
#                       # или если с числами int = 0 и последняя строка будет работать
#         for item in params:
#                 res += item
#         return res
# print(concatenatio('a', 's', 'd', 'w')) # asdw
# print(concatenatio('a', '1', 'd', '2')) # a1d2
# ## print(concatenatio(1, 2, 3, 4)) ОШИБКА




#                -----------РЕКУРСИЯ------------
# Рекурсия - функция вызывающая сама себя и главное указать в 
# какой момент остановиться и перестать ее вызывать

# def fib(n): # описали функцию указани название (fib) и агумент (n)
#     if n in [1, 2]: # логика выхода - если n содержится в списке [1, 2]
#         return 1 # возвращаем единицу по фибоначи
#     else:
#         return fib(n-1) + fib(n-2) # или возвращаем рекурсивный метод

# list = []
# for e in range(1, 10): # если требуется посмотреть первые 10 чисел
#         list.append(fib(e))
# print(list) # 1 1 2 3 5 8 13 21 34




#               ---------------КОРТЕЖИ----------------
# # Кортеж - некий неизменяемый список
# a = (3, 4, 41, 4) # кортеж с присвоенными значениями
# # a = (3,) если хочешь кортеж из одного элемента обязательно запятая
# print(a)
# print(a[-2]) # обращаемся к любому элементу кортежа


# # ПРИМЕРЫ!!!

# t = tuple(['red', 'green', 'blue'])
# print(t[0]) # red
# print(t[2]) # blue
# # print(t[10]) # IndexError: tuple index out of range
# print(t[-2]) # green
# # print(t[-200]) # IndexError: tuple index out of range

# for e in t:
#     print(e) # red green blue
# # t[0] = 'black' # TypeError: 'tuple' object does not support item assignment

# # КАК ДОПОЛНЕНИЕ можем распаковать кортеж в отдельные переменные
# t = tuple(['red', 'green', 'blue'])
# red, green, blue = t
# print('r:{} g:{} b:{}'.format(red, green, blue)) # r:red g:green b:blue




# --------------------------СЛОВАРИ--------------------------------
# Неупорядоченные коллекции произвольных объектов с доступом 
# по ключу
# dictionary = {} # создание пустого словаря, а / чтобы не писали в одну строку
# dictionary = \
#      {
#         'up': '↑', # указание пар по ключу где 'up'-ключ, а '↑' - значение
#          'left': '←', # указание пар по ключу
#          'down': '↓', # указание пар по ключу
#          'right': '→' # указание пар по ключу
#      }
# print(dictionary)  # посмотреть весь словарь {'up':'↑', 'left':'←', 'down':'↓', 'right':'→'}
# print(dictionary['left']) # посмотреть конкретное значение через []  # ←
# # типы ключей могут отличаться
# print(dictionary['up'])   # ↑
# типы ключей могут отличаться
# dictionary['left'] = '⇐' 
# print(dictionary['left']) # ⇐ 
# #print(dictionary['type']) # KeyError: 'type' del dictionary['left'] # удаление элемента
# for item in dictionary: # for (k,v) in dictionary.items(): 
#         print('{}: {}'.format(item, dictionary[item])) # получение всех значений и ключей
#  # up: ↑
#  # down: ↓
#  # right: →
# for item in dictionary.keys(): # просмотр списком всех ключей
#         print(item)
# for item in dictionary.values(): # просмотр списком всех значений
#         print(item)


# -------------------------МНОЖЕСТВА--------------------------

# colors = {'red', 'green', 'blue'} # colors - переменная со значениями
# print(colors) # {'red', 'green', 'blue'}
# colors.add('red') 
# print(colors) # {'red', 'green', 'blue'}
# colors.add('gray') # добавление
# print(colors) # {'red', 'green', 'blue','gray'}
# colors.remove('red') # удаление
# print(colors) # {'green', 'blue','gray'} # 
# colors.remove('red') # KeyError: 'red' 
# colors.discard('red') # ok
# print(colors) # {'green', 'blue','gray'}
# colors.clear() # { } # очистить множество и дальше работать с пустым
# print(colors) # set()

# # Операции со множествами

# a = {1, 2, 3, 5, 8} # первое множество
# b = {2, 5, 8, 13, 21} # второе множество
# c = a.copy() # c = {1, 2, 3, 5, 8}
# u = a.union(b) # u = {1, 2, 3, 5, 8, 13, 21} # обьединение
# i = a.intersection(b) # i = {8, 2, 5}
# dl = a.difference(b) # dl = {1, 3}
# dr = b.difference(a) # dr = {13, 21}

# q=a \ 
#        .union(b) \
#        .difference(a.intersection(b)) 
# {1, 21, 3, 13}

# s = frozenset (a) # замороженное множество значение в котором меняться не будут




# ---------------------СПИСКИ более глубокая теория---------

# list1 = [1,2,3,4,5] # лист один в котором лежать значения
# list2 = list1 # делаем копию листа выше
## list1[0]=123 # при этом значения будут меняться и во 2 списке
## list2[1]=333 # при этом значения будут меняться и в 1 списке

# for e in list1: # убедимся что все хорошо и распечатаем лист
#         print(e)
# print()

# for e in list2:
#         print(e) # точно таким же образом распечатаем второй список

##        Удаление элементов списка последнего

# list1 = [1,2,3,4,5]

# print(len(list1))
# print(list1.pop()) # .pop() - удаляет последний элемент списка                 
# print(list1)
# print(list1.pop())
# print(list1)
# print(list1.pop())
# print(list1)
# print(list1.pop())

##        Удаление элементов списка определенного

# list1 = [1,2,3,4,5] 

# print(list1.pop(2)) # для удаления конкретного ставим цифру индекса
# print(list1)


##        Добавление элементов списка определенного

# list1 = [1,2,3,4,5] 

# print(list1.insert(2, 11)) # для добавления конкретного ставим цифру индекса и число
# print(list1)


##        Добавление элементов списка в конец

# list1 = [1,2,3,4,5] 

# print(list1.append(2, 11)) # для добавления конкретного ставим цифру индекса и число
# print(list1)